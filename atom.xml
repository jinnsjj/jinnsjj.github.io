<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JOHZEN</title>
  
  <subtitle>花に風</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jinnsjj.github.io/"/>
  <updated>2018-10-17T07:47:24.381Z</updated>
  <id>https://jinnsjj.github.io/</id>
  
  <author>
    <name>Jon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>音频重采样 python+librosa</title>
    <link href="https://jinnsjj.github.io/tech/audio/resample-audio/"/>
    <id>https://jinnsjj.github.io/tech/audio/resample-audio/</id>
    <published>2018-10-17T07:28:06.000Z</published>
    <updated>2018-10-17T07:47:24.381Z</updated>
    
    <content type="html"><![CDATA[<p>python中的librosa库让我们可以非常方便的对音频文件进行重采样。</p><a id="more"></a><p>目标是一个48kHz的音频</p><audio controls="controls"><br>  <source type="audio/mp3" src="ClapSound.wav"><br>  <p>Your browser does not support the audio element.</p><br></audio><p>利用librosa库中中的<code>resample</code>将这段音频下采样到8kHz。</p><audio controls="controls"><br>  <source type="audio/mp3" src="ClapSound_8k.wav"><br>  <p>Your browser does not support the audio element.</p><br></audio><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="comment"># to install librosa package</span></span><br><span class="line"><span class="comment"># &gt; conda install -c conda-forge librosa </span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">'ClapSound.wav'</span></span><br><span class="line">newFilename = <span class="string">'ClapSound_8k.wav'</span></span><br><span class="line"></span><br><span class="line">y, sr = librosa.load(filename, sr=<span class="number">48000</span>)</span><br><span class="line">y_8k = librosa.resample(y,sr,<span class="number">8000</span>)</span><br><span class="line"></span><br><span class="line">librosa.output.write_wav(newFilename, y_8k, <span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p><a href="https://jinnsjj.github.io/projects/src/resample_audio.html">对应的jupyter lab</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python中的librosa库让我们可以非常方便的对音频文件进行重采样。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://jinnsjj.github.io/categories/tech/"/>
    
      <category term="audio" scheme="https://jinnsjj.github.io/categories/tech/audio/"/>
    
    
      <category term="signal processing" scheme="https://jinnsjj.github.io/tags/signal-processing/"/>
    
      <category term="python" scheme="https://jinnsjj.github.io/tags/python/"/>
    
      <category term="librosa" scheme="https://jinnsjj.github.io/tags/librosa/"/>
    
  </entry>
  
  <entry>
    <title>impulse response 使用的踩坑 —— cconv</title>
    <link href="https://jinnsjj.github.io/tech/audio/cconv/"/>
    <id>https://jinnsjj.github.io/tech/audio/cconv/</id>
    <published>2018-10-16T07:22:31.000Z</published>
    <updated>2018-10-17T02:23:54.560Z</updated>
    
    <content type="html"><![CDATA[<p>在 impulse response 的使用中遇到了小小的问题，具体如图，第一行是原始信号，第二行是响应的信号，在通过将原始信号和相应信号分别转换到频域求得 transfer function 后，ifft 得到 impulse response。第三行是原始信号和 ir 进行卷积得到的结果，可以看到在信号最开始的阶段，有一个意料外的响应。：</p><p><img src="https://i.loli.net/2018/10/16/5bc592a31cd45.jpg" alt="r_conv.jpg"></p><a id="more"></a><p>这一段的代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% src: 原始信号</span></span><br><span class="line"><span class="comment">% resp: 响应的信号</span></span><br><span class="line"></span><br><span class="line">Ssrc = fft(src);</span><br><span class="line">Sresp = fft(rest);</span><br><span class="line">Stf = Ssrc./Sresp;</span><br><span class="line">ir = ifft(Stf);</span><br><span class="line"></span><br><span class="line">z = conv(src,ir);</span><br></pre></td></tr></table></figure><p>先说短的结论，把最后一条命令 <code>conv</code> 换为 <code>cconv</code> 即可。</p><p><img src="https://i.loli.net/2018/10/16/5bc592a31daa2.jpg" alt="r_cconv.jpg"></p><p>和 Daniel 探讨后，问题出在 得到的 ir 上。</p><p><img src="https://i.loli.net/2018/10/16/5bc592a308780.jpg" alt="ir.jpg"></p><p>对于这个ir，是不能直接进行卷积的，而应该先做一个 circular shift ( <code>ir = circshift(ir, Nshift)</code>, <code>z = circshift(z, -Nshift)</code> )。让响应变得完整。</p><p><img src="https://i.loli.net/2018/10/16/5bc592a2e8e96.jpg" alt="shifted_ir.jpg"></p><p>这样得到的响应就没有前面恼人的部分了。然而。。。。又出现了另一个问题，响应的后半部分消失了。。。。。</p><p><img src="https://i.loli.net/2018/10/16/5bc59647cb500.jpg" alt="r_circshift.jpg"></p><p>最后就索性使用圆周卷积，结果完美。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% src: 原始信号</span></span><br><span class="line"><span class="comment">% resp: 响应的信号</span></span><br><span class="line"></span><br><span class="line">Ssrc = fft(src);</span><br><span class="line">Sresp = fft(rest);</span><br><span class="line">Stf = Ssrc./Sresp;</span><br><span class="line">ir = ifft(Stf);</span><br><span class="line"></span><br><span class="line">z = cconv(src,ir,<span class="number">800</span>); <span class="comment">% 800因为信号的长度为800</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/10/16/5bc592a31daa2.jpg" alt="r_cconv.jpg"></p><p>看来，信号处理的基本功还是不太扎实啊。</p><h2 id="圆周卷积与线性卷积的区别"><a href="#圆周卷积与线性卷积的区别" class="headerlink" title="圆周卷积与线性卷积的区别"></a>圆周卷积与线性卷积的区别</h2><blockquote><p><a href="https://www.mathworks.com/help/signal/ug/linear-and-circular-convolution.html" target="_blank" rel="noopener">Linear and Circular Convolution - MathWorks Documents</a><br><a href="https://blog.csdn.net/u012938704/article/details/79025175?utm_source=blogxgwz0" target="_blank" rel="noopener">Circular/Linear Convolution 与 DFT - CSDN blog</a></p></blockquote><p>频域相乘等于时域卷积<strong>仅适用于圆周卷积</strong>。</p><p>对于长度N与长度L的向量进行线性卷积，结果长度为N+L-1。</p><p>对于圆周卷积，两个向量长度应当相同，不同的话要进行补零。</p><hr><blockquote class="blockquote-center"><p><strong>将进酒</strong><br>李白<br>君不见，黄河之水天上来，奔流到海不复回。<br>君不见，高堂明镜悲白发，朝如青丝暮成雪。<br>人生得意须尽欢，莫使金樽空对月。<br>天生我材必有用，千金散尽还复来。<br>烹羊宰牛且为乐，会须一饮三百杯。<br>岑夫子，丹丘生，将进酒，杯莫停。<br>与君歌一曲，请君为我倾耳听。<br>钟鼓馔玉不足贵，但愿长醉不复醒。<br>古来圣贤皆寂寞，惟有饮者留其名。<br>陈王昔时宴平乐，斗酒十千恣欢谑。<br>主人何为言少钱，径须沽取对君酌。<br>五花马，千金裘，呼儿将出换美酒，与尔同销万古愁。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 impulse response 的使用中遇到了小小的问题，具体如图，第一行是原始信号，第二行是响应的信号，在通过将原始信号和相应信号分别转换到频域求得 transfer function 后，ifft 得到 impulse response。第三行是原始信号和 ir 进行卷积得到的结果，可以看到在信号最开始的阶段，有一个意料外的响应。：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/10/16/5bc592a31cd45.jpg&quot; alt=&quot;r_conv.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://jinnsjj.github.io/categories/tech/"/>
    
      <category term="audio" scheme="https://jinnsjj.github.io/categories/tech/audio/"/>
    
    
      <category term="impulse response" scheme="https://jinnsjj.github.io/tags/impulse-response/"/>
    
      <category term="signal processing" scheme="https://jinnsjj.github.io/tags/signal-processing/"/>
    
  </entry>
  
  <entry>
    <title>spatially oriented format for acoustics</title>
    <link href="https://jinnsjj.github.io/tech/audio/spatially-oriented-format-for-acoustics/"/>
    <id>https://jinnsjj.github.io/tech/audio/spatially-oriented-format-for-acoustics/</id>
    <published>2018-09-07T08:10:10.000Z</published>
    <updated>2018-09-07T10:38:20.599Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning"><p>UNDER CONSTRUCTION…</p></div><p>SOFA (spatially oriented format for acoustics) 是一种存储空间声学数据的格式，在保存HRTF和BRIR这样的空间传播函数上格外方便。尤记得从前，使用HRTF，方向信息距离信息，都得写在文件名里，有了SOFA格式，这些信息会保存在文件中，使用起来会方便很多。</p><a id="more"></a><h2 id="General-specifications"><a href="#General-specifications" class="headerlink" title="General specifications"></a>General specifications</h2><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">Receiver:</td><td style="text-align:left">指各种声音的接受器，比如麦克风，或者HRTF里的人耳。receiver的个数会影响保存数据矩阵的size，SOFA中没有限制receiver的个数。</td></tr><tr><td style="text-align:left">Listener:</td><td style="text-align:left">Receiver的载体，在HRTF中，Listener是人头。在DRIR中，listener是收音的麦克风阵列。Listener这个object可以将相关的一组receiver当作一个整体处理。AES69中只能有一个Listener。</td></tr><tr><td style="text-align:left">Emitter:</td><td style="text-align:left">指在发声的声源。数量没有限制。</td></tr><tr><td style="text-align:left">Source:</td><td style="text-align:left">Emitter的载体，和emitter的关系如同Listener与receiver。AES69中只能有一个Source。</td></tr><tr><td style="text-align:left">Room:</td><td style="text-align:left">指在测量时候的空间模型，比如在很多场景下，room是free-field。AES69中只能有一个Room。</td></tr></tbody></table><h3 id="Objects-间关系"><a href="#Objects-间关系" class="headerlink" title="Objects 间关系"></a>Objects 间关系</h3><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>SOFA中有一个全局坐标系global coordinate system。listener和source的位置会记录在这个全局坐标系中。而listener和source分别拥有一个local coordinate system。记录receiver/emitter和listener/source的相对位置。global和coordinate坐标系都可以是Cartesian或者Spherical。</p><h4 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h4><p>这里的方向是指local coordinate system的朝向，用“view”和“up”两个向量定义。根据自己的理解，对于freefield的HRTF这点不是很重要，但对于BRIR，listener的朝向就要靠这个来定义了。</p><h3 id="Numerical-container"><a href="#Numerical-container" class="headerlink" title="Numerical container"></a>Numerical container</h3><hr><blockquote class="blockquote-center"></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;UNDER CONSTRUCTION…&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;SOFA (spatially oriented format for acoustics) 是一种存储空间声学数据的格式，在保存HRTF和BRIR这样的空间传播函数上格外方便。尤记得从前，使用HRTF，方向信息距离信息，都得写在文件名里，有了SOFA格式，这些信息会保存在文件中，使用起来会方便很多。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://jinnsjj.github.io/categories/tech/"/>
    
      <category term="audio" scheme="https://jinnsjj.github.io/categories/tech/audio/"/>
    
    
      <category term="spatial audio" scheme="https://jinnsjj.github.io/tags/spatial-audio/"/>
    
      <category term="HRTF" scheme="https://jinnsjj.github.io/tags/HRTF/"/>
    
  </entry>
  
  <entry>
    <title>语音情感识别探讨</title>
    <link href="https://jinnsjj.github.io/tech/audio/speech-emotion-recognition-survey/"/>
    <id>https://jinnsjj.github.io/tech/audio/speech-emotion-recognition-survey/</id>
    <published>2018-07-19T00:15:09.000Z</published>
    <updated>2018-09-05T07:44:21.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>El Ayadi M, Kamel M S, Karray F. Survey on speech emotion recognition: Features, classification schemes, and databases[J]. Pattern Recognition, 2011, 44(3): 572-587.</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>语音识别的发展可以说是非常成熟，但距离我们的目标——自然的人机交互，还差的很远，这其中的一个原因就是现在机器还无法理解我们说话时的情感。这是研究语音情感识别的一个重要的motivation。</p><h3 id="情感识别的用处"><a href="#情感识别的用处" class="headerlink" title="情感识别的用处"></a>情感识别的用处</h3><ul><li>自然的人机交互（natural man-machine interaction）。</li><li>车载系统（in-car board system）。用于检测司机的精神状况以确保驾驶安全。</li><li>。。。</li></ul><h3 id="情感识别面临的挑战"><a href="#情感识别面临的挑战" class="headerlink" title="情感识别面临的挑战"></a>情感识别面临的挑战</h3><ol><li>什么样的特征在分辨情感中最有用。</li><li>一个发音中可以会包含多种感情，不同情感的边界也难以界定，哪个情绪是当前主导的情绪？</li><li>表达情感是一个个性化极强的事情，根据个人，环境甚至文化差异都很大。</li><li>情绪可能持续很长时间，但期间也会有快速变化的情绪，情感识别系统是检测长期的情绪还是短时的情绪了（比如被炒鱿鱼了，会悲伤很久，但这期间吃了顿好吃的饭，虽然会开心，但人还处在伤心的状态中，那么该判定为悲伤还是开心呢）。</li><li>情感本身都难以明确的定义。</li></ol><h3 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h3><p>虽然情感本身十分复杂，但一个被广泛认同的模型是讲情感划分为两个维度：activation 和 valence。activation指得是表达这个情感需要的能量。比较强烈的情感比如愤怒，喜悦，恐惧。伴随着这类感情可能会有心跳加速，血压升高等等，同时人的语速会变快，音高变高。相反比较舒缓的请看比如忧伤，语速可能会降低，高频会减少。而activation类似的感情，比如愤怒与喜悦，则用valence来加以区分。用何种feature来描述valence尚无定论。因此，在情感识别系统中，强烈的感情与舒缓的感情很好区分，而区分不同类别的情感则还是一个挑战。</p><!-- ## Database作为模式识别尤其是机器学习的应用，database的重要性不言而喻。但和大多数模式识别任务想比，用于情感识别的数据库显得特别特殊。### 设计标准- 真实世界的情感或演出的情感- 情感的发出者（专业演员？业余演员？）- 如何模拟真实世界的发音--><h2 id="语音情感识别中的特征"><a href="#语音情感识别中的特征" class="headerlink" title="语音情感识别中的特征"></a>语音情感识别中的特征</h2><p>特征提取是模式识别任务中最重要的一个环节之一，在语音情感识别的任务中亦然。我们会面对四个主要的问题</p><ol><li>特征提取的作用域。是对音频进行分帧(frame)再提取特征，或是对全局进行提取？</li><li>提取什么样的特征？</li><li>是否要进行前处理与后处理？比如移除静音的部分。</li><li>要不要结合其他的特征？比如语言模型或者面部表情。</li></ol><h3 id="对以上四个问题的分析"><a href="#对以上四个问题的分析" class="headerlink" title="对以上四个问题的分析"></a>对以上四个问题的分析</h3><ol><li><p>局部特征还是全局特征</p><p> 全局特征在分类的准确率上往往比局部特征表现的要好，同时耗时也更少（特征量较少）。然而全局特征也有许多缺点：</p><ol><li>只在分类高兴奋度的情感（high-arousal emotions，也是我们之前说的activation较高的情感）中比较有效，比如在分类anger和joy时，全局特征就会失效。</li><li>全局特征会丢失语音的短时信息（temporal information）。</li><li><p>当使用较为复杂的分类器（HMM，SVM等）时，全局变量会因为特征较少而无法进行有效的训练。</p><p>因此在复杂的模型中使用局部特征，模型的准确率更好。</p><p>还有一种做法是对语音信号根据音素进行分段而不是分帧。研究显示了把分段的特征和全局特征相结合可以一定程度提高是别的准确率。</p></li></ol></li><li><p>提取什么样的特征</p><p> 我们可以把语音特征划分为四类：</p><ol><li>Continuous speech features 连续语音特征<ul><li>pitch-related features</li><li>formants features</li><li>energy-related features</li><li>timing features</li><li>articulation features<br>常用的有F0，Energy，Duration，Formants。另外在特征的提取中，除了使用特征还对特征进行一些转换，比如平均，最大最小等。在INTERSPEECH 2009 中有个图表就很清晰的展示了这一点。<br><img src="https://i.loli.net/2018/07/25/5b5820350ca89.png" alt="1532502050.png"><br>对于每一帧信号，我们提取16个特征和它们的delta，并对这32个特征进行右边的12种变换，得到384维（(16x2)x12）的特征向量（每一帧）。</li></ul></li><li>Voice quality features<ul><li>voice quality</li><li>harsh</li><li>tense</li><li>breathy</li></ul></li><li>Spectral-based speech features<ul><li>LPC</li><li>MFCC</li><li>LFPC</li></ul></li><li><p>TEO-based features</p><p>小结：Continuous speech features 用来检测high-arousal和low-arousal的情感；频谱特征比如MFCC用来做N-way classification的问题，TEO-based features 用于压力检测；</p></li></ol></li><li><p>语音处理</p><ul><li>前处理<ul><li>pre-emphasis filter, $H(z)=1-0.97z^{-1}$: to equalize the effect of the propagation of speech throungh air.</li><li>overlapped frames: to smooth the extracted contours.</li><li>Hamming window: to reduce ripples in the spectrum of the speech spectrum.</li><li>slient intervals: 语音中的静音间隔也包含情感信息，通常会保留下来。</li></ul></li><li>特征提取</li><li>后处理 <ul><li>正规化 feature normalization<ul><li>$\hat{x}=\frac{x-\mu}{\sigma}$ </li><li>重要！但由于方差中包含许多情感信息，normalize后会消除这些特征，要考虑到这一点。 </li></ul></li><li>降维<ul><li>feature selection：找到分类效果最好的子特征。</li><li>feature extraction：对原始特征进行mapping到另一空间，从而达到降维效果。</li><li></li></ul></li></ul></li></ul></li><li><p>声学特征与其他特征结合</p><ul><li>语言信息（linguistic information）</li><li>视频信息</li></ul></li></ol><h2 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h2><p>都是些大家熟悉的手法。</p><ul><li>HMM：效果好（在语音情感识别的任务里，正确率甚至可能超过人类）</li><li>GMM：比HMM高效，但不能利用短时特征</li><li>Neural networks：emmm。。大家都在用</li><li>SVM</li><li>Multiple classifer system<br>  这个比较有趣，可以把情感识别分几步来做，比如先分类 high arousal 和 low arousal 的情感，再进行子类别的分类可以看这个图。<br>  <img src="https://i.loli.net/2018/09/05/5b8f4fbfc590e.png" alt="12324.png"></li></ul><hr><blockquote class="blockquote-center"></blockquote>]]></content>
    
    <summary type="html">
    
      近期开始了一个语音情感识别的任务，我对于这一方面完全没有经验，所以第一件事情就是调查相关的基础知识与背景，主要参考了一篇2010年的论文 “Survey on speech emotion recognition: Features, classification schemes, and databases”，如今有894个引用，可以说是较为权威的论文了。因为是2010年发表的，而智能音频这一块这些年发展又飞速，可能有些内容已经过时，不过作为上手，应该是一个不错的选择。（收回最后一句话，看了一篇最新的综述，说情感识别在最近几年几乎没有太大进展）
    
    </summary>
    
      <category term="tech" scheme="https://jinnsjj.github.io/categories/tech/"/>
    
      <category term="audio" scheme="https://jinnsjj.github.io/categories/tech/audio/"/>
    
    
      <category term="speech emotion recognition" scheme="https://jinnsjj.github.io/tags/speech-emotion-recognition/"/>
    
  </entry>
  
  <entry>
    <title>HOA声场重建原理</title>
    <link href="https://jinnsjj.github.io/tech/audio/something-of-HOA/"/>
    <id>https://jinnsjj.github.io/tech/audio/something-of-HOA/</id>
    <published>2018-07-12T14:00:46.000Z</published>
    <updated>2018-07-31T06:58:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="空间音频是什么？"><a href="#空间音频是什么？" class="headerlink" title="空间音频是什么？"></a>空间音频是什么？</h2><p>空间音频很多地方也叫做三维音频，它源于我们人据有分辨声音来源方向的能力。虽然一直是比较冷门的研究方向，但在VR的发展下，空间音频也火了一把，很大程度是因为空间音频在在VR的应用所讲究的沉浸感中扮演着极为重要的作用，当声音的方向与画面不匹配的时候，沉浸感会荡然无存，所以高品质的空间音频也成为了VR研究中很重要的一环。</p><!-- ![](RA_Discover.png) --><p><img src="https://i.loli.net/2018/07/14/5b4a0596b0e92.png" alt="RA_Discover.png"></p><blockquote><p><a href="https://developers.google.com/resonance-audio/discover/overview" target="_blank" rel="noopener">https://developers.google.com/resonance-audio/discover/overview</a></p></blockquote><h2 id="HOA"><a href="#HOA" class="headerlink" title="HOA?"></a>HOA?</h2><p>HOA 全称是 Higher Order Ambisonics，强硬的翻译的话就是高次混响。它最初的目的是要重建空间中声场的分布。我们可以想象一个空间中的一个球面，我们在球的中心，那么从球外传来的声音会在这个球面上有一个投影，这让我们想到，我们可以把球面以外的声音都无视掉，并假设声源分布在这个球面上。用球面上的声源产生的声场来拟合原来生源产生的声场。HOA就是一个这样去拟合声场的方法。</p><!-- ![](speakers-surround-head-3d.png) --><p><img src="https://i.loli.net/2018/07/14/5b4a059786b90.png" alt="speakers-surround-head-3d.png"></p><blockquote><p><a href="https://developers.google.com/resonance-audio/discover/concepts" target="_blank" rel="noopener">https://developers.google.com/resonance-audio/discover/concepts</a></p></blockquote><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="球面调和函数-Spherical-harmonics"><a href="#球面调和函数-Spherical-harmonics" class="headerlink" title="球面调和函数 Spherical harmonics"></a>球面调和函数 Spherical harmonics</h3><p>球面调和函数也叫球谐函数，它并不好理解，有机会可以详细的聊一聊，这里只做最最最抽象的介绍，力求知其然不求知其所以然。</p><p>这里要做的是类比一下傅里叶变换。我们通常接触的函数都是分布在一维的，每一个 $x$ 对应一个 $f(x)$，我们对 $f(x)$ 进行傅里叶变换会得到 $F(\omega)$。现在我们的目标是一个在球面上分布的函数，我们使用一个球坐标系，球面上的点 $(r,\theta,\phi)$，而对于一个固定大小的球，$r$是一个定值，我们可以暂时只关注$\theta$和$\phi$，那么对于每一组 $(\theta,\phi)$对应一个$f(\theta,\phi)$。傅里叶变换可以将时域信号转化到频域，这样方便我们分析特定频域的信号，对于 $f(\theta,\phi)$，我们只想知道这个函数在空间中一个大概的分布，所以$f(\theta,\phi)$记录的东西无疑太多了，所以我们可以把它转换为 $F_n^m$，这里的 $n$ 和 $m$ 就类似与傅里叶中的 $\omega$。当我们只需要粗略的空间分辨率时，很小的$n$就足够，当需要更精细的空间分辨率时，就需要较大的 $n$ 时的 $F_n^m$，它们会对小的$n$的$F_n^m$的空间的缝隙中进行插值，使空间的分辨率增高。通过球谐分解，我们可以把球面上的函数用更少的数值表达。就如下面这张图，从上至下$n$逐渐增大，对空间的描述能力也逐渐增强。</p><!-- ![spherical harmonics](Spherical_Harmonics.png) --><p><img src="https://i.loli.net/2018/07/14/5b4a059ae5ed3.png" alt="Spherical_Harmonics.png"></p><blockquote><p><a href="https://en.wikipedia.org/wiki/Spherical_harmonics" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Spherical_harmonics</a></p></blockquote><p>基于球谐函数，球面上的任意函数可以被分解为球谐系数：</p><p>$$p(\theta,\phi) = \sum_{n=0}^\infty \sum_{m=-n}^{n} P_n^m Y_n^m(\theta,\phi) $$</p><p>声场中方向的信息都被转换到了球谐因子 $Y_n^m(\theta,\phi)$ 中，这个式子看起来是不是也非常像傅里叶变换呢。</p><h3 id="球谐贝塞尔函数-amp-汉克尔函数-Spherical-Bessel-function-Spherical-Hanker-function"><a href="#球谐贝塞尔函数-amp-汉克尔函数-Spherical-Bessel-function-Spherical-Hanker-function" class="headerlink" title="球谐贝塞尔函数&amp;汉克尔函数 Spherical Bessel function, Spherical Hanker function"></a>球谐贝塞尔函数&amp;汉克尔函数 Spherical Bessel function, Spherical Hanker function</h3><p>这两个函数的表达式也比较复杂，好在我们通常也不需要记住，只需要知道它门描述了波动方程在球坐标系下的解，它与三个参数有关，对应的上面的球谐函数的阶数 $n$，波的频率球面的半径有关，在之后的数学中我们会用到。贝塞尔函数写作 $j_n(kr)$ 或者 $j_n(\frac{\omega}{c}r)$，$k$是一个波的波数，它等于 $\frac{\omega}{c}$，$\omega$ 表示声音的角频率，$r$表示球面的半径。汉克尔函数类似，但有一类汉克尔函数和二类汉克尔函数，分别表示从内往外传递的出射波和从外往内传播的入射波，写作 $h_n^{(1)}(kr)$ 与 $h_n^{(2)}(kr)$。</p><h3 id="格林函数-Green-function"><a href="#格林函数-Green-function" class="headerlink" title="格林函数 Green function"></a>格林函数 Green function</h3><p>格林函数用于描述在开放空间中（没有障碍物没有反射折射）一个声源到空间另外一点的响应。用$\boldsymbol{x_0}$表示声源的位置，声源到$\boldsymbol{x}$点的传达函数为为 $G(\boldsymbol{x}-\boldsymbol{x_0},\omega) = \dfrac{e^{ik|\boldsymbol{x}-\boldsymbol{x_0}|}}{4\pi|\boldsymbol{x}-\boldsymbol{x_0}|}$。$\omega$表示声音的角频率，格林函数同样有在时域上的表达，可以看作是一个延时函数。</p><h2 id="HOA-1"><a href="#HOA-1" class="headerlink" title="HOA!"></a>HOA!</h2><p>我们之前说到了，HOA的思路是用一个球面上的音源去拟合球内的声场。我们把这个思想在球坐标系中用公式描述出来。对于一个特定频率的声波（角频率为 $\omega$ ）球内一点 $\boldsymbol{x}$，该点的声强是球面$S_0$上声源的在该点的响应的叠加：</p><p>$$p(\boldsymbol{x},\omega) = \int_{\Omega_0 \in S_0} D(\boldsymbol{x_0},\omega) G(\boldsymbol{x}-\boldsymbol{x_0},\omega)d\Omega_0$$</p><p>这里 $D(\boldsymbol{x_0},\omega)$ 表示了球面分布的声源的驱动信号(driving signal)，$\boldsymbol{x_0}$ 则代表着它们对应的坐标。</p><p>于此同时，我们也可以对 $p(\boldsymbol{x},\omega)$ 进行球谐分解，把它写作：</p><p>$$p(r,\theta,\phi,\omega) = \sum_{n=0}^\infty \sum_{m=-n}^{n} j_n(\frac{\omega}{c}r) P_n^m(\omega) Y_n^m(\theta,\phi)$$</p><p>这一步，我们也叫做<strong>声场的编码</strong>，$p(\boldsymbol{x},\omega)$可以是录音得到的，也可以是仿真生成的。</p><blockquote><p>因为$j_n(\frac{\omega}{c}r)$可能等于0，在某些频率无法得到$P_n^m(\omega)$,这时候就会遇到禁止频率的问题。这也是声场重建中一个比较重要的问题。</p></blockquote><p>同样 $G(\boldsymbol{x}-\boldsymbol{x_0},\omega)$ 也进行对应的球谐变换。如果我们用$L$个扬声器重建声场，那么上面这个式子可以写作</p><p>$$p(r,\theta,\phi,\omega) = \sum_{n=0}^\infty \sum_{m=-n}^{n} j_n(\frac{\omega}{c}r) { \sum_{\ell=1}^{L} D_\ell(\boldsymbol{x_0},\omega)G_{nm}^{\ell}(\omega) } Y_n^m(\theta,\phi)$$</p><!-- $$P_n^m(r,\omega) =  2\pi r_0 \sqrt{\frac{4\pi}{2n+1}} D_n^m(r_0,\omega) G_n^m(r,\omega)$$ --><p>$$P_n^m = \boldsymbol{C(\omega)} \cdot \boldsymbol{D(\boldsymbol x_0,\omega)}$$</p><p>$$\boldsymbol{C(\omega)} = [G_{nm}^{1}(\omega) \quad G_{nm}^{2}(\omega) \quad \cdots \quad G_{nm}^{L}(\omega)]$$</p><p>这样通过求矩阵的逆，我们就可以求得驱动信号$D(\boldsymbol x_0,\omega)$，从而重建声场。这也是HOA的<strong>解码</strong>。</p><blockquote><p>同时我们也可以避免矩阵的求逆，直接算出驱动函数的解析解。这里就不展开了。</p></blockquote><!-- <div class="note warning"><p>UNDER CONSTRUCTION…</p></div> –&gt;<hr><blockquote class="blockquote-center"><p><strong>行路难·其一</strong><br>李白<br>金樽清酒斗十千，玉盘珍羞直万钱。停杯投箸不能食，拔剑四顾心茫然。<br>欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。<br>行路难！行路难！多歧路，今安在？长风破浪会有时，直挂云帆济沧海。</p></blockquote>-->]]></content>
    
    <summary type="html">
    
      在空间音频尤其是声场重建的任务中，HOA绝对是最为重要的技术之一，但这个HOA涉及到调和分解等一系列概念，理解起来其实并不容易。最近要写一篇基于HOA的声场重建论文，但在background的时候就感到头疼，不知怎么下手，于是借着这篇文章，回头看看HOA，也好梳理一下自己的思路。
    
    </summary>
    
      <category term="tech" scheme="https://jinnsjj.github.io/categories/tech/"/>
    
      <category term="audio" scheme="https://jinnsjj.github.io/categories/tech/audio/"/>
    
    
      <category term="HOA" scheme="https://jinnsjj.github.io/tags/HOA/"/>
    
      <category term="spatial audio" scheme="https://jinnsjj.github.io/tags/spatial-audio/"/>
    
      <category term="sound field reproduction" scheme="https://jinnsjj.github.io/tags/sound-field-reproduction/"/>
    
  </entry>
  
  <entry>
    <title>在hexo-NexT中插入note提示块</title>
    <link href="https://jinnsjj.github.io/uncategorized/hexo-next-note/"/>
    <id>https://jinnsjj.github.io/uncategorized/hexo-next-note/</id>
    <published>2018-07-12T06:28:34.000Z</published>
    <updated>2018-07-13T06:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>hexo中可以插入一些很酷的提示块，效果如下：</p><div class="note default"><p>default 提示块标签</p></div><div class="note primary"><p>primary 提示块标签</p></div><div class="note success"><p>success 提示块标签</p></div><a id="more"></a><div class="note info"><p>info 提示块标签</p></div><div class="note warning"><p>warning 提示块标签</p></div><div class="note danger"><p>danger 提示块标签</p></div><p>使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p><p>主题配置文件中可以修改风格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Note tag (bs-callout).</span><br><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure></p><p>除此之外还可以实现选项卡等很酷的功能。</p><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><a href="#tab-1">tab 1</a></li><li class="tab"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">A</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-1"><p><strong>选项卡 1</strong> </p></div><div class="tab-pane" id="tab-2"><p><strong>选项卡 2</strong></p></div><div class="tab-pane" id="tab-3"><p><strong>选项卡 3</strong> 名字为A</p></div></div></div><p>使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs tab,1 %&#125; 名字为tab，默认在第1个选项卡，如果是-1则隐藏</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**选项卡 1** </span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**选项卡 2**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab A --&gt;</span><br><span class="line">**选项卡 3** 名字为A</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></p><p>参考→<br><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GithubPages的超深度优化</a><br><a href="https://biueo.github.io/2018/01/11/Hexo-markdown%E4%BC%98%E9%9B%85%E5%86%99%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo+markdown优雅写博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo中可以插入一些很酷的提示块，效果如下：&lt;/p&gt;
&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;default 提示块标签&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;primary 提示块标签&lt;/p&gt;&lt;/div&gt;
&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;success 提示块标签&lt;/p&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://jinnsjj.github.io/tags/hexo/"/>
    
      <category term="NexT" scheme="https://jinnsjj.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>librosa音频操作基础和特征提取</title>
    <link href="https://jinnsjj.github.io/tech/audio/librosa-audio/"/>
    <id>https://jinnsjj.github.io/tech/audio/librosa-audio/</id>
    <published>2018-07-12T05:43:41.000Z</published>
    <updated>2018-07-12T16:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>把项目页面里面的这个python音频操作和特征提取小教程搬到了这里，用gist分享，jupyter notebook也可以显示啦。</p><p>→<a href="../../projects/src/audio_basics.html">更大更干净的页面</a></p><a id="more"></a><script src="https://gist.github.com/jinnsjj/74a941e77810e88b770222fd494c305f.js"></script><hr><blockquote class="blockquote-center"><p><strong>诉衷情·寒食</strong><br>仲殊<br>涌金门外小瀛洲。寒食更风流。红船满湖歌吹，花外有高楼。晴日暖，淡烟浮。恣嬉游。三千粉黛，十二阑干，一片云头。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把项目页面里面的这个python音频操作和特征提取小教程搬到了这里，用gist分享，jupyter notebook也可以显示啦。&lt;/p&gt;
&lt;p&gt;→&lt;a href=&quot;../../projects/src/audio_basics.html&quot;&gt;更大更干净的页面&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://jinnsjj.github.io/categories/tech/"/>
    
      <category term="audio" scheme="https://jinnsjj.github.io/categories/tech/audio/"/>
    
    
      <category term="python" scheme="https://jinnsjj.github.io/tags/python/"/>
    
      <category term="librosa" scheme="https://jinnsjj.github.io/tags/librosa/"/>
    
  </entry>
  
  <entry>
    <title>搭建hexo+next博客并把项目主页放在上面</title>
    <link href="https://jinnsjj.github.io/uncategorized/build-projects-page/"/>
    <id>https://jinnsjj.github.io/uncategorized/build-projects-page/</id>
    <published>2018-07-11T14:05:17.000Z</published>
    <updated>2018-10-17T03:22:30.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建hexo-next博客并把项目主页放在上面"><a href="#搭建hexo-next博客并把项目主页放在上面" class="headerlink" title="搭建hexo+next博客并把项目主页放在上面"></a>搭建hexo+next博客并把项目主页放在上面</h1><p>其实博客还是想用csdn写，但是像jupyter notebook这些，想在网上贴出来，一方面和大家分享，一方面也想留作存档，在csdn就不太方便，还是githube page好。之前在github page上搭了博客，随后由于懒惰废弃了，想从新捡起，可当时安装了很多依赖，现在找不回来，导致hexo已经生成不了，因为之前用的不多，所以索性重新再来，也一边在这里记录，免得下次又忘。</p><a id="more"></a><p>这次还是选择hexo，一方面好看，另外也方便，配置好了后直接<code>hexo d</code>就可以同步到page上。</p><p>那么开始。</p><p>怎么在github pages上搭主页可以参考<a href="https://tyousf.github.io/GitHub-Pages-Hexo-NexT-%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81Blog/" target="_blank" rel="noopener">GitHub-Pages-Hexo-NexT-快速构建静态Blog</a>。</p><h2 id="找好看的主题"><a href="#找好看的主题" class="headerlink" title="找好看的主题"></a>找好看的主题</h2><p>首先要找个好的hexo主题，要明确我不是想用来做博客，而是分享一些项目，所以要求主页清晰明了。</p><p>找了一圈，没有特别满意的， 还是用next吧</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol><li>装npm</li><li>装hexo</li><li>初始化hexo<br> 命令行输入<code>hexo init page</code> page是想初始化的文件夹名</li><li>next主题<br> <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a><ul><li>进入文件夹，克隆next库<br>  <code>cd page</code><br>  <code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></li><li>切换主题：在根目录里的<code>_config.yml</code>文件中，<code>theme</code>字段设为<code>next</code></li><li>完工，看一看完成情况<code>hexo s</code>    </li></ul></li><li><p>配置deploy<br> <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a> </p><ul><li>安装<code>hexo-deployer-git</code></li><li><p>根目录里的<code>_config.yml</code>文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: git@github.com:username/username.github.io.git</span><br><span class="line">    branch: master</span><br><span class="line">    message: &quot;&#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>hexo d</code>部署</p></li><li>访问一下 jinnsjj.github.com</li></ul></li></ol><h2 id="一些配置"><a href="#一些配置" class="headerlink" title="一些配置"></a>一些配置</h2><p>首先还是去<code>_config.yml</code>里，把最上面的title啊描述啊按自己的喜好改一改</p><h3 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h3><p>对于每个文章，生成一个文件夹存放里面的媒体文件。</p><p>根目录里的<code>_config.yml</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><h3 id="网站内搜索"><a href="#网站内搜索" class="headerlink" title="网站内搜索"></a>网站内搜索</h3><p><a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">https://github.com/theme-next/hexo-generator-searchdb</a></p><p><code>npm install hexo-generator-searchdb --save</code></p><p>站点的配置文件中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: all</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>注意field改为all，这样我们自己的project页面才能被搜索到。</p><h3 id="leancloud阅读计数"><a href="#leancloud阅读计数" class="headerlink" title="leancloud阅读计数"></a>leancloud阅读计数</h3><p><a href="https://leaferx.online/2018/02/11/lc-security/" target="_blank" rel="noopener">https://leaferx.online/2018/02/11/lc-security/</a></p><h3 id="add-this-分享"><a href="#add-this-分享" class="headerlink" title="add this 分享"></a>add this 分享</h3><p><a href="https://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">https://theme-next.iissnan.com/third-party-services.html</a>+<a href="https://github.com/iissnan/hexo-theme-next/issues/906" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/issues/906</a></p><p>这一块可能会被chrome的ghost插件拦截，导致看不到效果。</p><h2 id="放置项目的地方"><a href="#放置项目的地方" class="headerlink" title="放置项目的地方"></a>放置项目的地方</h2><p>在source文件夹里面建立一个<code>projects</code>文件夹，把jupyter notebook导出的html文件或者其他的html直接放在里面就好。再在根目录的<code>_config.yml</code>中间的<code>skip_render</code>项中加入<code>projects/**</code>，这样这个文件夹里的html就会直接显示了。<code>**</code>指跳过所有文件与文件夹 <code>*</code>指跳过所有文件。</p><blockquote><p><a href="https://github.com/hexojs/hexo/issues/1146#issuecomment-88380140" target="_blank" rel="noopener">如何不处理source目录下某个子目录的所有文件，仅仅是将其copy到public目录中对应目录？ #1146</a></p></blockquote><p><a href="https://colorlib.com/wp/template/riddle/" target="_blank" rel="noopener">摄影作品展示的模板-riddle</a> </p><h2 id="无关紧要但好玩的东西"><a href="#无关紧要但好玩的东西" class="headerlink" title="无关紧要但好玩的东西"></a>无关紧要但好玩的东西</h2><h3 id="主页上的黑猫"><a href="#主页上的黑猫" class="headerlink" title="主页上的黑猫:"></a>主页上的黑猫:</h3><p><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">https://huaji8.top/post/live2d-plugin-2.0/</a><br><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a></p><p>首先安装模块<code>npm install --save hexo-helper-live2d</code></p><p><code>_config.yml</code>中加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hijiki</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure></p><p>model下use的模型需要安装<code>npm install live2d-widget-model-hijiki</code></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>npm命令的–save是将安装的依赖包写入目录里的package.json文件中</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;搭建hexo-next博客并把项目主页放在上面&quot;&gt;&lt;a href=&quot;#搭建hexo-next博客并把项目主页放在上面&quot; class=&quot;headerlink&quot; title=&quot;搭建hexo+next博客并把项目主页放在上面&quot;&gt;&lt;/a&gt;搭建hexo+next博客并把项目主页放在上面&lt;/h1&gt;&lt;p&gt;其实博客还是想用csdn写，但是像jupyter notebook这些，想在网上贴出来，一方面和大家分享，一方面也想留作存档，在csdn就不太方便，还是githube page好。之前在github page上搭了博客，随后由于懒惰废弃了，想从新捡起，可当时安装了很多依赖，现在找不回来，导致hexo已经生成不了，因为之前用的不多，所以索性重新再来，也一边在这里记录，免得下次又忘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://jinnsjj.github.io/tags/hexo/"/>
    
      <category term="NexT" scheme="https://jinnsjj.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-37 Sudoku Solver</title>
    <link href="https://jinnsjj.github.io/coding/Sudoku-Solver/"/>
    <id>https://jinnsjj.github.io/coding/Sudoku-Solver/</id>
    <published>2018-07-11T12:18:58.000Z</published>
    <updated>2018-07-12T06:35:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a><a href="https://leetcode.com/problems/sudoku-solver/description/" target="_blank" rel="noopener">37. Sudoku Solver</a></h1><p>求解数独。前两天做了<a href="https://leetcode.com/problems/valid-sudoku/description/" target="_blank" rel="noopener">验证数独</a>那道题，当时对于遍历hash的使用有了一些感悟，但看这道题时候特别头疼。这两天HackerRank也刷了一下，对于DFS和BFS的理解加深了一些，渐渐的思路就变得清晰。其实是很暴力的解法，但把他转化为代码，对几天前的我来说还有一些难度。经过这两天的学习，总算是可以勉强完成，但参考别人的答案后，果然进步空间还比较大。</p><p>我之前的版本，dfs函数没有加入i与j两个变量，每次调用都重新扫描一遍需要填的空，这导致效率很低，引入i和j后果然好了很多。另外之前的dfs是void不返回值，通过一个cnt变量计算总共的空数，当cnt等于0时停止，但由于我们需要在中途中断dfs函数（找到正确的解时，否则答案会被填回’.’），采用void的类型也会比较难以中断。借鉴了别人的解法，让dfs返回一个值来判定是否完成整个数独，这样好了很多。</p><a id="more"></a><p><strong>算法解释：</strong> </p><ul><li>solveSudoku： 功能函数入口。</li><li>dfs：深度优先搜索函数。<ul><li>输入整个表和一个坐标。</li><li>如果该坐标已有数字，搜索下一个格子<code>j++</code>；当<code>j==9</code>，说明这一排已搜索完，搜索下一排的第一个格子<code>i++, j=0</code>；如果所有的行都已搜索完，说明所有的格子都被正确的填入了数字，则返回<code>true</code>。</li><li>如果该坐标下没有数字<code>&#39;.&#39;</code>，从1开始填入，并验证该数字是否可行<code>isValid(board, i, j)</code>。如果不可行，擦除填入的数字并填入下一个数字直到9。如果可行，搜索下一个格子，并直到整张表被填完。</li><li>如果一个没有填的格子所有的数字都不可行，代表之前填的数字有错，那么返回<code>false</code>。</li></ul></li><li>isValid：验证某个格子里的数字是否可行，是之前验证数独的简化版，因为只用验证特定位置的数字。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        dfs(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (j&gt;=<span class="number">9</span>) <span class="keyword">return</span> dfs(board, i+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (board[i][j]==<span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; num++)&#123;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>)(num+<span class="string">'0'</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(isValid(board, i, j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(board, i, j+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(board, i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (col != j &amp;&amp; board[i][j]==board[i][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (row != i &amp;&amp; board[i][j]==board[row][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++row) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p><a href="http://www.cnblogs.com/grandyang/p/4421852.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4421852.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;37-Sudoku-Solver&quot;&gt;&lt;a href=&quot;#37-Sudoku-Solver&quot; class=&quot;headerlink&quot; title=&quot;37. Sudoku Solver&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/sudoku-solver/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;37. Sudoku Solver&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;求解数独。前两天做了&lt;a href=&quot;https://leetcode.com/problems/valid-sudoku/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;验证数独&lt;/a&gt;那道题，当时对于遍历hash的使用有了一些感悟，但看这道题时候特别头疼。这两天HackerRank也刷了一下，对于DFS和BFS的理解加深了一些，渐渐的思路就变得清晰。其实是很暴力的解法，但把他转化为代码，对几天前的我来说还有一些难度。经过这两天的学习，总算是可以勉强完成，但参考别人的答案后，果然进步空间还比较大。&lt;/p&gt;
&lt;p&gt;我之前的版本，dfs函数没有加入i与j两个变量，每次调用都重新扫描一遍需要填的空，这导致效率很低，引入i和j后果然好了很多。另外之前的dfs是void不返回值，通过一个cnt变量计算总共的空数，当cnt等于0时停止，但由于我们需要在中途中断dfs函数（找到正确的解时，否则答案会被填回’.’），采用void的类型也会比较难以中断。借鉴了别人的解法，让dfs返回一个值来判定是否完成整个数独，这样好了很多。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://jinnsjj.github.io/categories/coding/"/>
    
    
      <category term="leetcode" scheme="https://jinnsjj.github.io/tags/leetcode/"/>
    
      <category term="c++" scheme="https://jinnsjj.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-36 Valid Sudoku</title>
    <link href="https://jinnsjj.github.io/coding/Valid-Sudoku/"/>
    <id>https://jinnsjj.github.io/coding/Valid-Sudoku/</id>
    <published>2018-07-11T12:18:41.000Z</published>
    <updated>2018-07-12T06:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="36-Valid-Sudoku"><a href="#36-Valid-Sudoku" class="headerlink" title="36. Valid Sudoku"></a><a href="https://leetcode.com/problems/valid-sudoku/description/" target="_blank" rel="noopener">36. Valid Sudoku</a></h1><p>要验证数独的棋盘，就是三个标准，行没有重复，列没有重复以及3x3格子没有重复。最开始的思路是建立1*9的hash表，依据这个标准检测三次，但这样带来一个问题是需要遍历棋盘三次。但其实可以扩大hash表，只需遍历棋盘一次。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 9行的hash</span></span><br><span class="line">    <span class="keyword">bool</span> col[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 9列的hash</span></span><br><span class="line">    <span class="keyword">bool</span> box[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 9个box的hash</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!row[i][c-<span class="string">'1'</span>]) row[i][c-<span class="string">'1'</span>] = !row[i][c-<span class="string">'1'</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!col[j][c-<span class="string">'1'</span>]) col[j][c-<span class="string">'1'</span>] = !col[j][c-<span class="string">'1'</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">int</span> idxBox = (i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>; <span class="comment">// 判定该元素属于哪个格子</span></span><br><span class="line">                    <span class="keyword">if</span>(!box[idxBox][c-<span class="string">'1'</span>]) box[idxBox][c-<span class="string">'1'</span>] = !box[idxBox][c-<span class="string">'1'</span>];</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;36-Valid-Sudoku&quot;&gt;&lt;a href=&quot;#36-Valid-Sudoku&quot; class=&quot;headerlink&quot; title=&quot;36. Valid Sudoku&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-sudoku/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;36. Valid Sudoku&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;要验证数独的棋盘，就是三个标准，行没有重复，列没有重复以及3x3格子没有重复。最开始的思路是建立1*9的hash表，依据这个标准检测三次，但这样带来一个问题是需要遍历棋盘三次。但其实可以扩大hash表，只需遍历棋盘一次。&lt;/p&gt;
    
    </summary>
    
      <category term="coding" scheme="https://jinnsjj.github.io/categories/coding/"/>
    
    
      <category term="leetcode" scheme="https://jinnsjj.github.io/tags/leetcode/"/>
    
      <category term="c++" scheme="https://jinnsjj.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jinnsjj.github.io/uncategorized/hello-world/"/>
    <id>https://jinnsjj.github.io/uncategorized/hello-world/</id>
    <published>1998-12-31T15:00:00.000Z</published>
    <updated>2018-10-17T07:46:56.164Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
