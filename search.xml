<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在hexo中插入note提示块]]></title>
    <url>%2F2018-07-12%2Fhexo%E4%B8%ADnote%E6%8F%90%E7%A4%BA%E5%9D%97%2F</url>
    <content type="text"><![CDATA[hexo中可以插入一些很酷的提示块，效果如下： default 提示块标签 primary 提示块标签 success 提示块标签 info 提示块标签 warning 提示块标签 danger 提示块标签 使用方法1234567891011121314151617181920212223&#123;% note default %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger %&#125;danger 提示块标签&#123;% endnote %&#125; 主题配置文件中可以修改风格12345678910111213# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 除此之外还可以实现选项卡等很酷的功能。 tab 1tab 2A选项卡 1 选项卡 2 选项卡 3 名字为A 使用方法1234567891011&#123;% tabs tab,1 %&#125; 名字为tab，默认在第1个选项卡，如果是-1则隐藏&lt;!-- tab --&gt;**选项卡 1** &lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab A --&gt;**选项卡 3** 名字为A&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 参考→Hexo+markdown优雅写博客]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[librosa音频操作基础和特征提取]]></title>
    <url>%2F2018-07-12%2Flibrosa-audio%2F</url>
    <content type="text"><![CDATA[把项目页面里面的这个python音频操作和特征提取小教程搬到了这里，用gist分享，jupyter notebook也可以显示啦。 →更大更干净的页面 涌金门外小瀛洲。寒食更风流。红船满湖歌吹，花外有高楼。晴日暖，淡烟浮。恣嬉游。三千粉黛，十二阑干，一片云头。 诉衷情·寒食 仲殊]]></content>
      <categories>
        <category>audio</category>
      </categories>
      <tags>
        <tag>librosa</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo+next博客并把项目主页放在上面]]></title>
    <url>%2F2018-07-11%2F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%BB%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[搭建hexo+next博客并把项目主页放在上面其实博客还是想用csdn写，但是像jupyter notebook这些，想在网上贴出来，一方面和大家分享，一方面也想留作存档，在csdn就不太方便，还是githube page好。之前在github page上搭了博客，随后由于懒惰废弃了，想从新捡起，可当时安装了很多依赖，现在找不回来，导致hexo已经生成不了，因为之前用的不多，所以索性重新再来，也一边在这里记录，免得下次又忘。 这次还是选择hexo，一方面好看，另外也方便，配置好了后直接hexo d就可以同步到page上。 那么开始。 怎么在github pages上搭主页可以参考GitHub-Pages-Hexo-NexT-快速构建静态Blog。 找好看的主题首先要找个好的hexo主题，要明确我不是想用来做博客，而是分享一些项目，所以要求主页清晰明了。 找了一圈，没有特别满意的， 还是用next吧 主要步骤 装npm 装hexo 初始化hexo 命令行输入hexo init page page是想初始化的文件夹名 next主题 https://github.com/theme-next/hexo-theme-next 进入文件夹，克隆next库 cd page git clone https://github.com/theme-next/hexo-theme-next themes/next 切换主题：在根目录里的_config.yml文件中，theme字段设为next 完工，看一看完成情况hexo s 配置deploy https://hexo.io/docs/deployment.html 安装hexo-deployer-git 根目录里的_config.yml文件 12345deploy: type: git repo: git@github.com:username/username.github.io.git branch: master message: &quot;&#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;&quot; hexo d部署 访问一下 jinnsjj.github.com 一些配置首先还是去_config.yml里，把最上面的title啊描述啊按自己的喜好改一改 资源文件夹对于每个文章，生成一个文件夹存放里面的媒体文件。 根目录里的_config.yml文件 1post_asset_folder: true 网站内搜索https://github.com/theme-next/hexo-generator-searchdb npm install hexo-generator-searchdb --save 站点的配置文件中加入 12345search: path: search.xml field: all format: html limit: 10000 注意field改为all，这样我们自己的project页面才能被搜索到。 leancloud阅读计数https://leaferx.online/2018/02/11/lc-security/ add this 分享https://theme-next.iissnan.com/third-party-services.html+https://github.com/iissnan/hexo-theme-next/issues/906 配置后可能不会马上生效，耐心等候半天左右。 放置项目的地方在source文件夹里面建立一个projects文件夹，把jupyter notebook导出的html文件或者其他的html直接放在里面就好。再在根目录的_config.yml中间的skip_render项中加入projects/**，这样这个文件夹里的html就会直接显示了。 无关紧要但好玩的东西主页上的黑猫:https://huaji8.top/post/live2d-plugin-2.0/https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md 首先安装模块npm install --save hexo-helper-live2d _config.yml中加入1234567891011121314live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki display: position: right width: 150 height: 300 mobile: show: true model下use的模型需要安装npm install live2d-widget-model-hijiki 备注npm命令的–save是将安装的依赖包写入目录里的package.json文件中]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-37 Sudoku Solver]]></title>
    <url>%2F2018-07-11%2FSudoku-Solver%2F</url>
    <content type="text"><![CDATA[37. Sudoku Solver求解数独。前两天做了验证数独那道题，当时对于遍历hash的使用有了一些感悟，但看这道题时候特别头疼。这两天HackerRank也刷了一下，对于DFS和BFS的理解加深了一些，渐渐的思路就变得清晰。其实是很暴力的解法，但把他转化为代码，对几天前的我来说还有一些难度。经过这两天的学习，总算是可以勉强完成，但参考别人的答案后，果然进步空间还比较大。 我之前的版本，dfs函数没有加入i与j两个变量，每次调用都重新扫描一遍需要填的空，这导致效率很低，引入i和j后果然好了很多。另外之前的dfs是void不返回值，通过一个cnt变量计算总共的空数，当cnt等于0时停止，但由于我们需要在中途中断dfs函数（找到正确的解时，否则答案会被填回’.’），采用void的类型也会比较难以中断。借鉴了别人的解法，让dfs返回一个值来判定是否完成整个数独，这样好了很多。 算法解释： solveSudoku： 功能函数入口。 dfs：深度优先搜索函数。 输入整个表和一个坐标。 如果该坐标已有数字，搜索下一个格子j++；当j==9，说明这一排已搜索完，搜索下一排的第一个格子i++, j=0；如果所有的行都已搜索完，说明所有的格子都被正确的填入了数字，则返回true。 如果该坐标下没有数字&#39;.&#39;，从1开始填入，并验证该数字是否可行isValid(board, i, j)。如果不可行，擦除填入的数字并填入下一个数字直到9。如果可行，搜索下一个格子，并直到整张表被填完。 如果一个没有填的格子所有的数字都不可行，代表之前填的数字有错，那么返回false。 isValid：验证某个格子里的数字是否可行，是之前验证数独的简化版，因为只用验证特定位置的数字。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; dfs(board, 0, 0); &#125; bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j)&#123; if (i&gt;=9) return true; if (j&gt;=9) return dfs(board, i+1, 0); if (board[i][j]=='.')&#123; for (int num = 1; num &lt;= 9; num++)&#123; board[i][j] = (char)(num+'0'); if(isValid(board, i, j))&#123; if(dfs(board, i, j+1)) return true; &#125; board[i][j] = '.'; &#125; &#125;else &#123; return dfs(board, i, j+1); &#125; return false; &#125; bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j)&#123; for (int col = 0; col &lt; 9; col++)&#123; if (col != j &amp;&amp; board[i][j]==board[i][col]) return false; &#125; for (int row = 0; row &lt; 9; row++)&#123; if (row != i &amp;&amp; board[i][j]==board[row][j]) return false; &#125; for (int row = i / 3 * 3; row &lt; i / 3 * 3 + 3; ++row) &#123; for (int col = j / 3 * 3; col &lt; j / 3 * 3 + 3; ++col) &#123; if ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) return false; &#125; &#125; return true; &#125;&#125;; Reference http://www.cnblogs.com/grandyang/p/4421852.html]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-36 Valid Sudoku]]></title>
    <url>%2F2018-07-11%2FValid-Sudoku%2F</url>
    <content type="text"><![CDATA[36. Valid Sudoku要验证数独的棋盘，就是三个标准，行没有重复，列没有重复以及3x3格子没有重复。最开始的思路是建立1*9的hash表，依据这个标准检测三次，但这样带来一个问题是需要遍历棋盘三次。但其实可以扩大hash表，只需遍历棋盘一次。 123456789101112131415161718192021222324class Solution &#123;public: bool row[9][9] = &#123;0&#125;; // 9行的hash bool col[9][9] = &#123;0&#125;; // 9列的hash bool box[9][9] = &#123;0&#125;; // 9个box的hash bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for (int i = 0; i &lt; 9; i++)&#123; for (int j = 0; j &lt; 9; j++)&#123; char c = board[i][j]; if (c != '.')&#123; if(!row[i][c-'1']) row[i][c-'1'] = !row[i][c-'1']; else return false; if(!col[j][c-'1']) col[j][c-'1'] = !col[j][c-'1']; else return false; int idxBox = (i/3)*3+j/3; // 判定该元素属于哪个格子 if(!box[idxBox][c-'1']) box[idxBox][c-'1'] = !box[idxBox][c-'1']; else return false; &#125; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018-07-09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[游褒禅山记王安石 &emsp;&emsp;褒禅山亦谓之华山，唐浮图慧褒始舍于其址，而卒葬之；以故其后名之曰“褒禅”。今所谓慧空禅院者，褒之庐冢也。距其院东五里，所谓华山洞者，以其乃华山之阳名之也。距洞百余步，有碑仆道，其文漫灭，独其为文犹可识曰“花山”。今言“华”如“华实”之“华”者，盖音谬也。 &emsp;&emsp;其下平旷，有泉侧出，而记游者甚众，所谓前洞也。由山以上五六里，有穴窈然，入之甚寒，问其深，则其好游者不能穷也，谓之后洞。余与四人拥火以入，入之愈深，其进愈难，而其见愈奇。有怠而欲出者，曰：“不出，火且尽。”遂与之俱出。盖余所至，比好游者尚不能十一，然视其左右，来而记之者已少。盖其又深，则其至又加少矣。方是时，予之力尚足以入，火尚足以明也。既其出，则或咎其欲出者，而余亦悔其随之而不得极夫游之乐也。 &emsp;&emsp;于是余有叹焉。古人之观于天地、山川、草木、虫鱼、鸟兽，往往有得，以其求思之深而无不在也。夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！ &emsp;&emsp;余于仆碑，又以悲夫古书之不存，后世之谬其传而莫能名者，何可胜道也哉！此所以学者不可以不深思而慎取之也。 &emsp;&emsp;四人者：庐陵萧君圭君玉，长乐王回深父，余弟安国平父、安上纯父。至和元年七月某日，临川王某记。]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Projects]]></title>
    <url>%2Fprojects%2Findex.html</url>
    <content type="text"><![CDATA[ProjectsAudio basics 通过librosa进行音频的基本操作和特征提取 使用librosa库，读取音频，提取频谱，MFCC等。 MATLAB中进行声场可视化 Have fun Urban Sound Classification Inspired by http://aqibsaeed.github.io/2016-09-03-urban-sound-classification-part-1/ Urban Sound Classifier using NN 这是我搭建的第一个神经网络，可以说是边做边学，代码有一些混乱。整个流程几乎是跟着上面博客的思路来，准确度虽然不高，但work了，还是满意的。 Urban Sound Classifier using CNN v2 第一版的CNN非常惨烈，所以废弃了，第二版开始work了，但准确率实在堪忧，只有50%左右。 Urban Sound Classifier using CNN v3 紧接着第二版做的一些变体，单纯的娱乐，看看不同网络效果的区别，虽然没有看到。 Urban Sound Classifier using LSTM v1 第一次尝试LSTM，LSTM的搭建也很简单，预计效果不错，然而实际却低于NN和CNN。原因还不明。 ← Back to Homepage]]></content>
  </entry>
</search>
