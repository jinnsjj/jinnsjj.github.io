<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HOA声场重建]]></title>
    <url>%2Ftech%2Faudio%2Fsomething-of-HOA%2F</url>
    <content type="text"><![CDATA[空间音频是什么？空间音频很多地方也叫做三维音频，它源于我们人据有分辨声音来源方向的能力。虽然一直是比较冷门的研究方向，但在VR的发展下，空间音频也火了一把，很大程度是因为空间音频在在VR的应用所讲究的沉浸感中扮演着极为重要的作用，当声音的方向与画面不匹配的时候，沉浸感会荡然无存，所以高品质的空间音频也成为了VR研究中很重要的一环。 https://developers.google.com/resonance-audio/discover/overview HOA?HOA 全称是 Higher Order Ambisonics，强硬的翻译的话就是高次混响。它最初的目的是要重建空间中声场的分布。我们可以想象一个空间中的一个球面，我们在球的中心，那么从球外传来的声音会在这个球面上有一个投影，这让我们想到，我们可以把球面以外的声音都无视掉，并假设声源分布在这个球面上。用球面上的声源产生的声场来拟合原来生源产生的声场。HOA就是一个这样去拟合声场的方法。 https://developers.google.com/resonance-audio/discover/concepts 一些基本概念球面调和函数 Spherical harmonics球面调和函数也叫球谐函数，它并不好理解，有机会可以详细的聊一聊，这里只做最最最抽象的介绍，力求知其然不求知其所以然。 这里要做的是类比一下傅里叶变换。我们通常接触的函数都是分布在一维的，每一个$x$对应一个$f(x)$，我们对$f(x)$进行傅里叶变换会得到$F(\omega)$。现在我们的目标是一个在球面上分布的函数，我们使用一个球坐标系，球面上的点$(r,\theta,\phi)$，而对于一个固定大小的球，$r$是一个定值，我们可以暂时只关注$\theta$和$\phi$，那么对于每一组$(\theta,\phi)$对应一个$f(\theta,\phi)$。傅里叶变换可以将时域信号转化到频域，这样方便我们分析特定频域的信号，对于$f(\theta,\phi)$，我们只想知道这个函数在空间中一个大概的分布，所以$f(\theta,\phi)$记录的东西无疑太多了，所以我们可以把它转换为$F_n^m$，这里的$n$和$m$就类似与傅里叶中的 $\omega$。当我们只需要粗略的空间分辨率时，很小的$n$就足够，当需要更精细的空间分辨率时，就需要较大的$n$时的$F_n^m$，它们会对小的$n$的$F_n^m$的空间的缝隙中进行插值，使空间的分辨率增高。通过球谐分解，我们可以把球面上的函数用更少的数值表达。就如下面这张图，从上至下$n$逐渐增大，对空间的描述能力也逐渐增强。 https://en.wikipedia.org/wiki/Spherical_harmonics 球谐贝塞尔函数&amp;汉克尔函数 Spherical Bessel function, Spherical Hanker function这两个函数的表达式也比较复杂，好在我们通常也不需要记住，只需要知道它门描述了波动方程在球坐标系下的解，它与三个参数有关，对应的上面的球谐函数的阶数$n$，波的频率球面的半径有关，在之后的数学中我们会用到。贝塞尔函数写作$j_n(kr)$或者$j_n(\frac{\omega}{c}r)$，$k$是一个波的波数，它等于$\frac{\omega}{c}$，$\omega$表示声音的角频率，$r$表示球面的半径。汉克尔函数类似，但有一类汉克尔函数和二类汉克尔函数，分别表示从外往内传播的入射波和从内往外传递的出射波，写作$h_n^{(1)}(kr)$与$h_n^{(2)}(kr)$。 格林函数 Green function格林函数用于描述在开放空间中（没有障碍物没有反射折射）一个声源到空间另外一点的响应。用$x_0$表示声源的位置，$x$点的声强为$p(\omega) = \dfrac{e^{i\omega|x-x_0|}}{4\pi|x-x_0|}$。$\omega$表示声音的角频率，格林函数同样有在时域上的表达，可以看作是一个延时函数。 HOA!UNDER CONSTRUCTION… 行路难·其一李白金樽清酒斗十千，玉盘珍羞直万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。行路难！行路难！多歧路，今安在？长风破浪会有时，直挂云帆济沧海。]]></content>
      <categories>
        <category>tech</category>
        <category>audio</category>
      </categories>
      <tags>
        <tag>HOA</tag>
        <tag>spatial audio</tag>
        <tag>sound field reproduction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在hexo-NexT中插入note提示块]]></title>
    <url>%2Funcategorized%2Fhexo-next-note%2F</url>
    <content type="text"><![CDATA[hexo中可以插入一些很酷的提示块，效果如下： default 提示块标签 primary 提示块标签 success 提示块标签 info 提示块标签 warning 提示块标签 danger 提示块标签 使用方法1234567891011121314151617181920212223&#123;% note default %&#125;default 提示块标签&#123;% endnote %&#125;&#123;% note primary %&#125;primary 提示块标签&#123;% endnote %&#125;&#123;% note success %&#125;success 提示块标签&#123;% endnote %&#125;&#123;% note info %&#125;info 提示块标签&#123;% endnote %&#125;&#123;% note warning %&#125;warning 提示块标签&#123;% endnote %&#125;&#123;% note danger %&#125;danger 提示块标签&#123;% endnote %&#125; 主题配置文件中可以修改风格12345678910111213# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 除此之外还可以实现选项卡等很酷的功能。 tab 1tab 2A选项卡 1 选项卡 2 选项卡 3 名字为A 使用方法1234567891011&#123;% tabs tab,1 %&#125; 名字为tab，默认在第1个选项卡，如果是-1则隐藏&lt;!-- tab --&gt;**选项卡 1** &lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab A --&gt;**选项卡 3** 名字为A&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 参考→打造个性超赞博客Hexo+NexT+GithubPages的超深度优化Hexo+markdown优雅写博客]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[librosa音频操作基础和特征提取]]></title>
    <url>%2Ftech%2Faudio%2Flibrosa-audio%2F</url>
    <content type="text"><![CDATA[把项目页面里面的这个python音频操作和特征提取小教程搬到了这里，用gist分享，jupyter notebook也可以显示啦。 →更大更干净的页面 诉衷情·寒食仲殊涌金门外小瀛洲。寒食更风流。红船满湖歌吹，花外有高楼。晴日暖，淡烟浮。恣嬉游。三千粉黛，十二阑干，一片云头。]]></content>
      <categories>
        <category>tech</category>
        <category>audio</category>
      </categories>
      <tags>
        <tag>librosa</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo+next博客并把项目主页放在上面]]></title>
    <url>%2Funcategorized%2Fbuild-projects-page%2F</url>
    <content type="text"><![CDATA[搭建hexo+next博客并把项目主页放在上面其实博客还是想用csdn写，但是像jupyter notebook这些，想在网上贴出来，一方面和大家分享，一方面也想留作存档，在csdn就不太方便，还是githube page好。之前在github page上搭了博客，随后由于懒惰废弃了，想从新捡起，可当时安装了很多依赖，现在找不回来，导致hexo已经生成不了，因为之前用的不多，所以索性重新再来，也一边在这里记录，免得下次又忘。 这次还是选择hexo，一方面好看，另外也方便，配置好了后直接hexo d就可以同步到page上。 那么开始。 怎么在github pages上搭主页可以参考GitHub-Pages-Hexo-NexT-快速构建静态Blog。 找好看的主题首先要找个好的hexo主题，要明确我不是想用来做博客，而是分享一些项目，所以要求主页清晰明了。 找了一圈，没有特别满意的， 还是用next吧 主要步骤 装npm 装hexo 初始化hexo 命令行输入hexo init page page是想初始化的文件夹名 next主题 https://github.com/theme-next/hexo-theme-next 进入文件夹，克隆next库 cd page git clone https://github.com/theme-next/hexo-theme-next themes/next 切换主题：在根目录里的_config.yml文件中，theme字段设为next 完工，看一看完成情况hexo s 配置deploy https://hexo.io/docs/deployment.html 安装hexo-deployer-git 根目录里的_config.yml文件 12345deploy: type: git repo: git@github.com:username/username.github.io.git branch: master message: &quot;&#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;&quot; hexo d部署 访问一下 jinnsjj.github.com 一些配置首先还是去_config.yml里，把最上面的title啊描述啊按自己的喜好改一改 资源文件夹对于每个文章，生成一个文件夹存放里面的媒体文件。 根目录里的_config.yml文件 1post_asset_folder: true 网站内搜索https://github.com/theme-next/hexo-generator-searchdb npm install hexo-generator-searchdb --save 站点的配置文件中加入 12345search: path: search.xml field: all format: html limit: 10000 注意field改为all，这样我们自己的project页面才能被搜索到。 leancloud阅读计数https://leaferx.online/2018/02/11/lc-security/ add this 分享https://theme-next.iissnan.com/third-party-services.html+https://github.com/iissnan/hexo-theme-next/issues/906 这一块可能会被chrome的ghost插件拦截，导致看不到效果。 放置项目的地方在source文件夹里面建立一个projects文件夹，把jupyter notebook导出的html文件或者其他的html直接放在里面就好。再在根目录的_config.yml中间的skip_render项中加入projects/**，这样这个文件夹里的html就会直接显示了。 无关紧要但好玩的东西主页上的黑猫:https://huaji8.top/post/live2d-plugin-2.0/https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md 首先安装模块npm install --save hexo-helper-live2d _config.yml中加入1234567891011121314live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-hijiki display: position: right width: 150 height: 300 mobile: show: true model下use的模型需要安装npm install live2d-widget-model-hijiki 备注npm命令的–save是将安装的依赖包写入目录里的package.json文件中]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-37 Sudoku Solver]]></title>
    <url>%2Fcoding%2FSudoku-Solver%2F</url>
    <content type="text"><![CDATA[37. Sudoku Solver求解数独。前两天做了验证数独那道题，当时对于遍历hash的使用有了一些感悟，但看这道题时候特别头疼。这两天HackerRank也刷了一下，对于DFS和BFS的理解加深了一些，渐渐的思路就变得清晰。其实是很暴力的解法，但把他转化为代码，对几天前的我来说还有一些难度。经过这两天的学习，总算是可以勉强完成，但参考别人的答案后，果然进步空间还比较大。 我之前的版本，dfs函数没有加入i与j两个变量，每次调用都重新扫描一遍需要填的空，这导致效率很低，引入i和j后果然好了很多。另外之前的dfs是void不返回值，通过一个cnt变量计算总共的空数，当cnt等于0时停止，但由于我们需要在中途中断dfs函数（找到正确的解时，否则答案会被填回’.’），采用void的类型也会比较难以中断。借鉴了别人的解法，让dfs返回一个值来判定是否完成整个数独，这样好了很多。 算法解释： solveSudoku： 功能函数入口。 dfs：深度优先搜索函数。 输入整个表和一个坐标。 如果该坐标已有数字，搜索下一个格子j++；当j==9，说明这一排已搜索完，搜索下一排的第一个格子i++, j=0；如果所有的行都已搜索完，说明所有的格子都被正确的填入了数字，则返回true。 如果该坐标下没有数字&#39;.&#39;，从1开始填入，并验证该数字是否可行isValid(board, i, j)。如果不可行，擦除填入的数字并填入下一个数字直到9。如果可行，搜索下一个格子，并直到整张表被填完。 如果一个没有填的格子所有的数字都不可行，代表之前填的数字有错，那么返回false。 isValid：验证某个格子里的数字是否可行，是之前验证数独的简化版，因为只用验证特定位置的数字。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; dfs(board, 0, 0); &#125; bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j)&#123; if (i&gt;=9) return true; if (j&gt;=9) return dfs(board, i+1, 0); if (board[i][j]=='.')&#123; for (int num = 1; num &lt;= 9; num++)&#123; board[i][j] = (char)(num+'0'); if(isValid(board, i, j))&#123; if(dfs(board, i, j+1)) return true; &#125; board[i][j] = '.'; &#125; &#125;else &#123; return dfs(board, i, j+1); &#125; return false; &#125; bool isValid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j)&#123; for (int col = 0; col &lt; 9; col++)&#123; if (col != j &amp;&amp; board[i][j]==board[i][col]) return false; &#125; for (int row = 0; row &lt; 9; row++)&#123; if (row != i &amp;&amp; board[i][j]==board[row][j]) return false; &#125; for (int row = i / 3 * 3; row &lt; i / 3 * 3 + 3; ++row) &#123; for (int col = j / 3 * 3; col &lt; j / 3 * 3 + 3; ++col) &#123; if ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) return false; &#125; &#125; return true; &#125;&#125;; Reference http://www.cnblogs.com/grandyang/p/4421852.html]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-36 Valid Sudoku]]></title>
    <url>%2Fcoding%2FValid-Sudoku%2F</url>
    <content type="text"><![CDATA[36. Valid Sudoku要验证数独的棋盘，就是三个标准，行没有重复，列没有重复以及3x3格子没有重复。最开始的思路是建立1*9的hash表，依据这个标准检测三次，但这样带来一个问题是需要遍历棋盘三次。但其实可以扩大hash表，只需遍历棋盘一次。 123456789101112131415161718192021222324class Solution &#123;public: bool row[9][9] = &#123;0&#125;; // 9行的hash bool col[9][9] = &#123;0&#125;; // 9列的hash bool box[9][9] = &#123;0&#125;; // 9个box的hash bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for (int i = 0; i &lt; 9; i++)&#123; for (int j = 0; j &lt; 9; j++)&#123; char c = board[i][j]; if (c != '.')&#123; if(!row[i][c-'1']) row[i][c-'1'] = !row[i][c-'1']; else return false; if(!col[j][c-'1']) col[j][c-'1'] = !col[j][c-'1']; else return false; int idxBox = (i/3)*3+j/3; // 判定该元素属于哪个格子 if(!box[idxBox][c-'1']) box[idxBox][c-'1'] = !box[idxBox][c-'1']; else return false; &#125; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[游褒禅山记王安石 &emsp;&emsp;褒禅山亦谓之华山，唐浮图慧褒始舍于其址，而卒葬之；以故其后名之曰“褒禅”。今所谓慧空禅院者，褒之庐冢也。距其院东五里，所谓华山洞者，以其乃华山之阳名之也。距洞百余步，有碑仆道，其文漫灭，独其为文犹可识曰“花山”。今言“华”如“华实”之“华”者，盖音谬也。 &emsp;&emsp;其下平旷，有泉侧出，而记游者甚众，所谓前洞也。由山以上五六里，有穴窈然，入之甚寒，问其深，则其好游者不能穷也，谓之后洞。余与四人拥火以入，入之愈深，其进愈难，而其见愈奇。有怠而欲出者，曰：“不出，火且尽。”遂与之俱出。盖余所至，比好游者尚不能十一，然视其左右，来而记之者已少。盖其又深，则其至又加少矣。方是时，予之力尚足以入，火尚足以明也。既其出，则或咎其欲出者，而余亦悔其随之而不得极夫游之乐也。 &emsp;&emsp;于是余有叹焉。古人之观于天地、山川、草木、虫鱼、鸟兽，往往有得，以其求思之深而无不在也。夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！ &emsp;&emsp;余于仆碑，又以悲夫古书之不存，后世之谬其传而莫能名者，何可胜道也哉！此所以学者不可以不深思而慎取之也。 &emsp;&emsp;四人者：庐陵萧君圭君玉，长乐王回深父，余弟安国平父、安上纯父。至和元年七月某日，临川王某记。]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Projects]]></title>
    <url>%2Fprojects%2Findex.html</url>
    <content type="text"><![CDATA[ProjectsAudio basics 通过librosa进行音频的基本操作和特征提取 使用librosa库，读取音频，提取频谱，MFCC等。 MATLAB中进行声场可视化 Have fun Urban Sound Classification Inspired by http://aqibsaeed.github.io/2016-09-03-urban-sound-classification-part-1/ Urban Sound Classifier using NN 这是我搭建的第一个神经网络，可以说是边做边学，代码有一些混乱。整个流程几乎是跟着上面博客的思路来，准确度虽然不高，但work了，还是满意的。 Urban Sound Classifier using CNN v2 第一版的CNN非常惨烈，所以废弃了，第二版开始work了，但准确率实在堪忧，只有50%左右。 Urban Sound Classifier using CNN v3 紧接着第二版做的一些变体，单纯的娱乐，看看不同网络效果的区别，虽然没有看到。 Urban Sound Classifier using LSTM v1 第一次尝试LSTM，LSTM的搭建也很简单，预计效果不错，然而实际却低于NN和CNN。原因还不明。 ← Back to Homepage]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
